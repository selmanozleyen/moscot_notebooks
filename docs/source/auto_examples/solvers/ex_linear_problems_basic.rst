
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/solvers/ex_linear_problems_basic.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_solvers_ex_linear_problems_basic.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_solvers_ex_linear_problems_basic.py:


Solving linear problems
-----------------------

.. GENERATED FROM PYTHON SOURCE LINES 8-11

This notebook elaborates on how to solve linear problems, e.g. the
:class:`moscot.problems.time.TemporalProblem` and the
:class:`moscot.problems.generic.SinkhornProblem`.

.. GENERATED FROM PYTHON SOURCE LINES 11-20

.. code-block:: default


    from moscot.datasets import simulate_data
    from moscot.problems.generic import SinkhornProblem

    import numpy as np

    adata = simulate_data(n_distributions=2, key="day")
    adata





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/runner/work/moscot_notebooks/moscot_notebooks/.tox/docs/lib/python3.9/site-packages/moscot/datasets/_datasets.py:251: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.
      AnnData(
    /home/runner/work/moscot_notebooks/moscot_notebooks/.tox/docs/lib/python3.9/site-packages/anndata/_core/anndata.py:1785: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.
      [AnnData(sparse.csr_matrix(a.shape), obs=a.obs) for a in all_adatas],

    AnnData object with n_obs × n_vars = 40 × 60
        obs: 'day', 'celltype'



.. GENERATED FROM PYTHON SOURCE LINES 21-23

The :meth:`moscot.problems.time.TemporalProblem.solve` has numerous arguments,
a few of which will be discussed in the following.

.. GENERATED FROM PYTHON SOURCE LINES 25-36

Basic parameters
~~~~~~~~~~~~~~~~
`epsilon` is the regularization parameter. The lower `epsilon`, the sparser the
transport map. At the same time, the algorithm takes longer to converge. `tau_a`
and `tau_b` denote the unbalancedness parameters in the source and the target
distribution, respectively. `tau_a = 1` means the source marginals have to be fully
satisfied while `0 < tau_a < 1` relaxes this condition. Analogously, `tau_b` affects
the marginals of the target distribution. We demonstrate the effect of `tau_a` and `tau_b`
with the :class:`moscot.problems.generic.SinkhornProblem`.
Whenever the prior marginals `a` and `b` of the source and the target distribution,
respectively, are not passed (TODO link to marginals notebook), they are set to be uniform.

.. GENERATED FROM PYTHON SOURCE LINES 36-41

.. code-block:: default


    sp = SinkhornProblem(adata)
    sp = sp.prepare(key="day")
    print(sp[0, 1].a[:5], sp[0, 1].b[:5])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    INFO     Computing pca with `n_comps=30` using `adata.X`                        
    [0.05 0.05 0.05 0.05 0.05] [0.05 0.05 0.05 0.05 0.05]




.. GENERATED FROM PYTHON SOURCE LINES 42-46

First, we solve the problem in a balanced manner, such that the posterior marginals of the
solution (the sum over the rows and the columns for the source marginals and the
target marginals, respectively) are equal to the prior marginals up to small
errors (which define the convergence criterion in the balanced case).

.. GENERATED FROM PYTHON SOURCE LINES 46-50

.. code-block:: default

    sp = sp.solve(epsilon=1e-2, tau_a=1, tau_b=1)
    print(sp[0, 1].solution.a[:5], sp[0, 1].solution.b[:5])






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    INFO     Solving problem OTProblem[stage='prepared', shape=(20, 20)].           
    [0.04999981 0.05000011 0.05000006 0.04999984 0.04999995] [0.0499921  0.04998703 0.04998971 0.04999597 0.0499915 ]




.. GENERATED FROM PYTHON SOURCE LINES 51-52

If we solve an unbalanced problem, the posterior marginals will be different.

.. GENERATED FROM PYTHON SOURCE LINES 52-55

.. code-block:: default

    sp = sp.solve(epsilon=1e-2, tau_a=0.9, tau_b=0.99)
    print(sp[0, 1].solution.a[:5], sp[0, 1].solution.b[:5])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    INFO     Solving problem OTProblem[stage='solved', shape=(20, 20)].             
    [0.03286416 0.02016635 0.02300276 0.01075785 0.01592081] [0.02210412 0.02592126 0.02502106 0.02436337 0.02419146]




.. GENERATED FROM PYTHON SOURCE LINES 56-63

Low-rank solutions
~~~~~~~~~~~~~~~~~~
Whenever the dataset is very large, the computational complexity can be
reduced by setting `rank` to a positive integer (:cite:`scetbon:21a`). In this
case, `epsilon` can also be set to 0, while only the balanced case
(`tau_a = tau_b = 1`) is supported. The `rank` should be significantly
smaller than the number of cells in both source and target distribution.

.. GENERATED FROM PYTHON SOURCE LINES 63-66

.. code-block:: default


    sp = sp.solve(epsilon=0, rank=3, initializer="random")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    INFO     Solving problem OTProblem[stage='solved', shape=(20, 20)].             




.. GENERATED FROM PYTHON SOURCE LINES 67-76

Scaling the cost
~~~~~~~~~~~~~~~~
`scale_cost` scales the cost matrix which often helps the algorithm to converge.
While any number can be passed, it is also possible to scale the cost matrix
by e.g. its mean, median, and maximum. We recommend using the `mean` as this
is possible without instantiating the cost matrix and hence reduces computational
complexity. Moreover, it is more stable w.r.t. outliers than for example scaling
by the maximum. Note that the solution of the Optimal Transport is not stable
across different scalings:

.. GENERATED FROM PYTHON SOURCE LINES 76-80

.. code-block:: default

    sp = sp.solve(epsilon=1e-2, scale_cost="mean")
    tm_mean = sp[0, 1].solution.transport_matrix
    print(tm_mean[:3, :3])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    INFO     Solving problem OTProblem[stage='solved', shape=(20, 20)].             
    [[7.7331262e-15 2.5642862e-07 5.3756791e-11]
     [3.7442808e-13 3.9273414e-06 8.2084188e-14]
     [4.3774089e-05 1.4414739e-10 5.2908806e-12]]




.. GENERATED FROM PYTHON SOURCE LINES 81-85

.. code-block:: default

    sp = sp.solve(epsilon=1e-2, scale_cost="max_cost")
    tm_max = sp[0, 1].solution.transport_matrix
    print(tm_max[:3, :3])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    INFO     Solving problem OTProblem[stage='solved', shape=(20, 20)].             
    [[7.8722293e-11 1.1196194e-05 4.5380293e-08]
     [8.0387297e-10 5.2310992e-05 4.0580173e-10]
     [5.9454376e-04 1.2423303e-07 1.6821756e-08]]




.. GENERATED FROM PYTHON SOURCE LINES 86-88

We can compute the correlation of the flattened transport matrix to get an
idea of the influence of different scalings.

.. GENERATED FROM PYTHON SOURCE LINES 88-91

.. code-block:: default

    correlation = np.corrcoef(tm_mean.flatten(), tm_max.flatten())[0, 1]
    print(f"{correlation:.4f}")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    0.9962




.. GENERATED FROM PYTHON SOURCE LINES 92-93

TODO See other examples for ...


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  10.087 seconds)

**Estimated memory usage:**  33 MB


.. _sphx_glr_download_auto_examples_solvers_ex_linear_problems_basic.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: ex_linear_problems_basic.py <ex_linear_problems_basic.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: ex_linear_problems_basic.ipynb <ex_linear_problems_basic.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
